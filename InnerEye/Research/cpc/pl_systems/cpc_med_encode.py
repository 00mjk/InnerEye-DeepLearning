import torch
import numpy as np
from argparse import Namespace

from InnerEye.Research.cpc.utils.system import get_device
from InnerEye.Research.cpc.models.linear_classifier import LinearClassifier
from InnerEye.Research.cpc.utils.logging_utils import get_innereye_build


def extract_encoder_state_dict(state_dict, param_starts_with="encoder", rename_key_func=None):
    """
    Given a state-dict, return all entries that start with 'param_starts_with' as a new state-dict.
    This may be used to select only the parameters stored for e.g. the encoder model.

    :param state_dict: dict, a dictionary of key: torch.Tensor
    :param param_starts_with: str, select only keys in state_dict that starts with this string
    :param rename_key_func: callable, optional function to apply to each key to use in the new, returned state-dict
    :return: dict, a state dict containing only the selected entries
    """
    new_state_dict = {}
    for key, value in state_dict.items():
        if key.startswith(param_starts_with):
            if callable(rename_key_func):
                key = rename_key_func(key)
            new_state_dict[key] = value
    return new_state_dict


def get_med_pl_system_class(pl_system):
    """
    Given a PL system name return its appropriate class.

    :param pl_system: string, the name of a PL system, e.g. cpc_dual_view_med_trian
    :return: A PL system class
    """
    if pl_system == "cpc_med_train":
        from InnerEye.Research.cpc.pl_systems.cpc_med_train import MEDContrastivePredictiveCoding
        return MEDContrastivePredictiveCoding
    elif pl_system == "cpc_dual_view_med_train":
        from InnerEye.Research.cpc.pl_systems.cpc_dual_view_med_train import MEDDualViewContrastivePredictiveCoding
        return MEDDualViewContrastivePredictiveCoding
    elif pl_system == "cpc_tri_view_med_train":
        from InnerEye.Research.cpc.pl_systems.cpc_tri_view_med_train import MEDTriViewContrastivePredictiveCoding
        return MEDTriViewContrastivePredictiveCoding
    else:
        supported = ("cpc_med_train", "cpc_dual_view_med_train", "cpc_tri_view_med_train")
        raise ValueError("Selected CPC model was generated by a PL system ({}) which is not supported by the "
                         "MEDEncoder class. Only supports: {}".format(pl_system, supported))


def apply_overwrite_args(args, enc_hparams):
    """
    Takes a set of command-line arguments (args) and hyperparameters loaded from a ckpt file (enc_hparams) and
    overwrites parameters in enc_hparams if specified in args. Also applies a set of fixed overwrites even if not
    specified in args.

    :param args: Namespace of command-line arguments to use over enc_hparams for all specified
    :param enc_hparams: Namespace of hyperparameters as loaded from a model ckpt file
    :return: Namespace, enc_hparams with some attributes overwritten
    """
    enc_hparams.batch_size = max(1, int(enc_hparams.batch_size / 4))  # run on single GPU
    enc_hparams.no_patch_augmentation = True
    for key, value in vars(args).items():
        if value is not None:
            setattr(enc_hparams, key, value)
    return enc_hparams


class MEDEncoder:
    """
    Implements a framework for loading an MED CPC model (e.g. MEDDualViewContrastivePredictiveCoding) and use it
    to encode a dataloader into vector representation and save the output as a pickled file on disk.
    """

    def __init__(self, device, hparams):
        """
        :param device: torch.device
            Device to place the encoder on for inference
        :param hparams: Namespace
            Namespace object storing all hyperparameters that this PL system accepts according to its argparser func
            'cpc_med_encode_argparser' at InnerEye.Research.cpc.argparsers
        """
        # Init the CPC trained encoder model (we do not use the aggregator)
        ckpt = torch.load(hparams.cpc_model_ckpt, map_location=device)
        enc_hparams = Namespace(**ckpt["hparams"])
        if enc_hparams.innereye_build != get_innereye_build():
            raise RuntimeError("Tried to load model trained on InnerEye=={}, while the current build is {}.".format(
                enc_hparams.innereye_build, get_innereye_build()
            ))
        pl_system = enc_hparams.pl_system
        enc_hparams = apply_overwrite_args(hparams, enc_hparams)
        # Init the appropriate MED CPC PL system for the loaded ckpt
        self.pl_med_obj = get_med_pl_system_class(pl_system)(hparams=enc_hparams).to(device)
        # Load only the encoder parameters
        encoder_state_dict = extract_encoder_state_dict(state_dict=ckpt["state_dict"],
                                                        param_starts_with="encoder",
                                                        rename_key_func=lambda key: key.split(".", 2)[-1])
        self.pl_med_obj.get_encoder().load_state_dict(encoder_state_dict, strict=True)
        self.hparams = hparams
        self.device = device

    def get_default_dataloader(self):
        self.pl_med_obj.prepare_data(
            train_split_fraction=1.0
        )
        return self.pl_med_obj.train_loader

    @staticmethod
    def pickle_encodings(encodings, out_path):
        import pickle
        with open(out_path, "wb") as out_f:
            pickle.dump(encodings, out_f)

    @staticmethod
    def load_pickled_encodings(path):
        import pickle
        with open(path, "rb") as in_f:
            return pickle.load(in_f)

    @staticmethod
    def stack_encodings(encodings):
        from collections import defaultdict
        stacked = defaultdict(list)
        for subject in encodings:
            stacked["subjects"].append(subject)
            for key, value in encodings[subject].items():
                stacked[key].append(value)
        return {key: np.stack(stacked[key]) for key in stacked}

    @staticmethod
    def plot(encodings, color_by=None, marker_by=None, title=None, out_path=None, **tsne_kwargs):
        from InnerEye.Research.cpc.utils.plotting import plot_encoding_space
        return plot_encoding_space(
            encodings=encodings.reshape(len(encodings), -1),
            color_by=color_by.reshape(len(encodings)) if color_by is not None else None,
            marker_by=marker_by.reshape(len(encodings)) if marker_by is not None else None,
            title=title,
            out_path=out_path,
            **tsne_kwargs
        )

    def get_encodings_from_dataloader(self, dataloader=None):
        """
        TODO
        :param dataloader:
        :param dict_keys:
        :return:
        """
        if dataloader is None:
            dataloader = self.get_default_dataloader()
        print("Encoding dataloader of length {}".format(len(dataloader)))
        encodings = {}
        with torch.no_grad():
            for i, batch in enumerate(dataloader):
                print(f"{i+1}/{len(dataloader)}")
                batch["images"] = batch["images"].to(self.device)
                batch["segmentations"] = batch["segmentations"].to(self.device)
                encoded = self.pl_med_obj.forward(batch=batch, transform_key="val")
                if isinstance(encodings, torch.Tensor):
                    encoded = [encoded]
                if self.hparams.apply_mean_pooling:
                    encoded = list(map(lambda x: LinearClassifier.pool_to_vector, encoded))
                features = torch.cat(encoded, dim=2)
                print("Shape after concat: {}".format(features.shape))
                for fet, sub, lab, non_im_f in zip(features, batch["subjects"], batch["labels"], batch["features"]):
                    encodings[sub] = {"image_features": fet.cpu().numpy(),
                                      "label": lab,
                                      "non_image_features": non_im_f}
        # Annotate
        return {
            "encodings": encodings,
            "input_weeks": self.pl_med_obj.hparams.input_weeks,
            "target_weeks": self.pl_med_obj.hparams.target_weeks
        }


def entry_func(args, logger=None):
    """
    Init the PL module with passed args and run encoding of the default dataloader.
    Save encodings to args.encodings_out_path.

    :param args: Namespace, hyperparameters to pass to the PL system
    :param logger: Not used
    """
    # Encode the full, default dataloader
    encoder = MEDEncoder(get_device(True), args)
    encodings = encoder.get_encodings_from_dataloader()
    encoder.pickle_encodings(encodings, args.encodings_out_path)
